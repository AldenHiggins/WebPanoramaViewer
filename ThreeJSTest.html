<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Kilograph 360 Viewer WebApp</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body 
			{
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info
			{
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align:center;
			}

			#fps
			{
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align: left;
			}

			a
			{
				color: #ffffff;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			<a href="http://kilograph.net" target="_blank">Kilograph</a> 360 Viewer Demo <br />
		</div>
		<div id="fps"></div>

		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/StereoEffect.js"></script>
		<script src="js/DeviceOrientationControls.js"></script>
		<script src="js/stats.min.js"></script>

		<script>
			var camera, scene, renderer, effect, controls, element, clock;
			var isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 0, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0;

			// Performance Statistics
			var stats = new Stats();
			stats.setMode( 1 );
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			// FPS stuff
			var filterStrength = 20;
			var frameTime = 0, lastLoop = new Date, thisLoop;
			var fpsOut = document.getElementById('fps');
			setInterval(function()
			{
			  fpsOut.innerHTML = (1000/frameTime).toFixed(1) + " fps";
			}, 1000);

			init();
			animate();

			function init() 
			{
				var container, mesh;	
				container = document.getElementById( 'container' );
				// Set up the camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
				camera.position.set(0, 15, 0);

				// Set up the scene
				scene = new THREE.Scene();
				scene.add(camera);

				// Surround the user with a sphere
				var geometry = new THREE.SphereGeometry( 500, 60, 40 );
				geometry.scale( - 1, 1, 1 );

				// Load up a sample image to wrap into the sphere
				var texture = new THREE.TextureLoader().load( 'images/01.jpg' );
				texture.format = THREE.RGBFormat;

				// Create a material with the texture
				var material = new THREE.MeshBasicMaterial( { map: texture } );

				// Create a mesh using the sphere and the cretaed material and add it to the scene
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				// Set up the renderer
				renderer = new THREE.WebGLRenderer();
				element = renderer.domElement;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				// Set up the stereo effect using the renderer
				effect = new THREE.StereoEffect( renderer );
				effect.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// Set up a clock
				clock = new THREE.Clock();

				// Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
		        controls = new THREE.OrbitControls(camera, element);
		        controls.target.set
		        (
					camera.position.x + 0.15,
					camera.position.y,
					camera.position.z
		        );
		        controls.noPan = true;
		        controls.noZoom = true;

		        // Our preferred controls via DeviceOrientation
		        function setOrientationControls(e)
		        {
					if (!e.alpha)
					{
						return;
					}
					controls = new THREE.DeviceOrientationControls(camera, true);
					controls.connect();
					controls.update();
					element.addEventListener('click', fullscreen, false);
					window.removeEventListener('deviceorientation', setOrientationControls, true);
		        }
		        window.addEventListener('deviceorientation', setOrientationControls, true);

		        ////////////////////////////////
		        /////// Event callbacks ////////
		        ////////////////////////////////
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
				document.addEventListener( 'MozMousePixelScroll', onDocumentMouseWheel, false);
				
				document.addEventListener
				(
					'dragover',
					function ( event )
					{
						event.preventDefault();
						event.dataTransfer.dropEffect = 'copy';
					},
					false
				);

				document.addEventListener
				(
					'dragenter',
					function ( event )
					{
						document.body.style.opacity = 0.5;
					},
					false 
				);

				document.addEventListener
				(
					'dragleave',
					function ( event )
					{
						document.body.style.opacity = 1;
					},
					false
				);

				document.addEventListener
				(
					'drop',
					function ( event ) 
					{
						event.preventDefault();
						var reader = new FileReader();
						reader.addEventListener( 'load', function ( event ) 
						{
							material.map.image.src = event.target.result;
							console.log(event.dataTransfer.files[ 0 ]);
							material.map.needsUpdate = true;
						}, false );

						reader.readAsDataURL( event.dataTransfer.files[ 0 ] );
						document.body.style.opacity = 1;
					},
					false
				);
				
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() 
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseDown( event ) 
			{
				event.preventDefault();
				isUserInteracting = true;
				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;
				onPointerDownLon = lon;
				onPointerDownLat = lat;
			}

			function onDocumentMouseMove( event )
			{
				if ( isUserInteracting === true ) 
				{
					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				}
			}

			function onDocumentMouseUp( event )
			{
				isUserInteracting = false;
			}

			function onDocumentMouseWheel( event )
			{
				// WebKit
				if ( event.wheelDeltaY ) 
				{
					camera.fov -= event.wheelDeltaY * 0.05;
				// Opera / Explorer 9
				}
				else if ( event.wheelDelta )
				{
					camera.fov -= event.wheelDelta * 0.05;
				// Firefox
				}
				else if ( event.detail )
				{
					camera.fov += event.detail * 1.0;
				}
				camera.updateProjectionMatrix();
			}

			function fullscreen()
			{
				if (container.requestFullscreen)
				{
					container.requestFullscreen();
				}
				else if (container.msRequestFullscreen)
				{
					container.msRequestFullscreen();
				}
				else if (container.mozRequestFullScreen)
				{
					container.mozRequestFullScreen();
				}
				else if (container.webkitRequestFullscreen)
				{
					container.webkitRequestFullscreen();
				}
			}

			function animate() 
			{
				requestAnimationFrame( animate );
				update(clock.getDelta());
			}

			function update(dt) 
			{
				stats.begin();

				var thisFrameTime = (thisLoop=new Date) - lastLoop;
				frameTime += (thisFrameTime - frameTime) / filterStrength;
				lastLoop = thisLoop;

				camera.updateProjectionMatrix();
				controls.update(dt);

				// This causes the scene to be rendered in stereo
				effect.render ( scene, camera );
				// Rendering with the renderer is mono
				// renderer.render( scene, camera );

				stats.end();
			}

		</script>
	</body>
</html>